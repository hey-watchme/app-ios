//
//  RecordingView.swift
//  ios_watchme_v9
//
//  Created by Claude on 2025/07/25.
//

import SwiftUI
import Combine

struct RecordingView: View {
    @ObservedObject var audioRecorder: AudioRecorder
    @ObservedObject var networkManager: NetworkManager
    @EnvironmentObject var deviceManager: DeviceManager
    @EnvironmentObject var userAccountManager: UserAccountManager
    @Environment(\.dismiss) private var dismiss
    @State private var showAlert = false
    @State private var alertMessage = ""
    @State private var selectedRecording: RecordingModel?
    @State private var uploadingTotalCount = 0
    @State private var uploadingCurrentIndex = 0
    @State private var recordingDataPoint = ""
    @State private var timer: Timer?
    @State private var showDeviceRegistrationConfirm = false  // „Éá„Éê„Ç§„ÇπÈÄ£Êê∫Á¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
    
    var body: some View {
        NavigationView {
            ZStack {
                // ËÉåÊôØËâ≤
                Color(.systemGray6)
                    .ignoresSafeArea()
                
                // „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑ
                VStack(spacing: 0) {
            
            // Èå≤Èü≥„Ç®„É©„ÉºË°®Á§∫
            if let errorMessage = audioRecorder.recordingError {
                HStack {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundColor(Color.safeColor("ErrorColor"))
                    Text(errorMessage)
                        .font(.subheadline)
                        .foregroundColor(Color.safeColor("ErrorColor"))
                    Spacer()
                    Button("Èñâ„Åò„Çã") {
                        audioRecorder.recordingError = nil
                    }
                    .font(.caption)
                }
                .padding()
                .background(Color.safeColor("ErrorColor").opacity(0.1))
                .cornerRadius(8)
                .padding(.horizontal)
            }
            
                    
                    // „Çπ„ÇØ„É≠„Éº„É´ÂèØËÉΩ„Å™„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Ç®„É™„Ç¢
                    ScrollView {
                        VStack(spacing: 16) {
            
            // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈÄ≤ÊçóË°®Á§∫
            if networkManager.connectionStatus == .uploading {
                VStack(spacing: 8) {
                    HStack {
                        if uploadingTotalCount > 0 {
                            Text("üì§ „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠ (\(uploadingCurrentIndex)/\(uploadingTotalCount)‰ª∂)")
                                .font(.subheadline)
                                .fontWeight(.medium)
                        } else {
                            Text("üì§ „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...")
                                .font(.subheadline)
                                .fontWeight(.medium)
                        }
                        
                        Spacer()
                        
                        Text("\(Int(networkManager.uploadProgress * 100))%")
                            .font(.caption)
                            .fontWeight(.bold)
                    }
                    
                    ProgressView(value: networkManager.uploadProgress, total: 1.0)
                        .progressViewStyle(LinearProgressViewStyle(tint: Color.safeColor("UploadActive")))
                    
                    if let fileName = networkManager.currentUploadingFile {
                        Text("„Éï„Ç°„Ç§„É´: \(fileName)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .padding()
                .background(Color.safeColor("UploadActive").opacity(0.1))
                .cornerRadius(12)
            }
            
            // Èå≤Èü≥„Éá„Éº„Çø„Çª„ÇØ„Ç∑„Éß„É≥
            VStack(alignment: .leading, spacing: 12) {
                // „Çø„Ç§„Éà„É´
                VStack(alignment: .leading, spacing: 12) {
                    HStack(alignment: .center, spacing: 8) {
                        Text("Èå≤Èü≥„Éá„Éº„Çø")
                            .font(.system(size: 24, weight: .bold))
                        Text("\(audioRecorder.recordings.count)‰ª∂")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        Spacer()
                    }
                    
                    VStack(alignment: .leading, spacing: 6) {
                        // „Éá„Éê„Ç§„Çπ„Çø„Ç§„É†„Çæ„Éº„É≥ÊÉÖÂ†±Ôºà1Ë°åÔºâ
                        HStack {
                            Text("„Éá„Éê„Ç§„Çπ„Çø„Ç§„É†„Çæ„Éº„É≥:")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text(deviceManager.selectedDeviceTimezone.identifier)
                                .font(.caption)
                                .fontWeight(.medium)
                                .foregroundColor(.secondary)
                            Spacer()
                        }
                        
                        // „Éá„Éº„ÇøÂèñÂæóÊôÇÈñìÂ∏ØÔºà1Ë°åÔºâ
                        HStack {
                        Text("„Éá„Éº„ÇøÂèñÂæóÊôÇÈñìÂ∏Ø:")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Text(recordingDataPoint)
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.secondary)
                        Spacer()
                        }
                    }
                    
                    // Âå∫Âàá„ÇäÁ∑ö
                    Divider()
                        .padding(.vertical, 4)
                }
                HStack {
                    Spacer()
                    // Âè§„ÅÑ„Éï„Ç°„Ç§„É´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Éú„Çø„É≥
                    if audioRecorder.recordings.contains(where: { $0.fileName.hasPrefix("recording_") }) {
                        Button(action: {
                            audioRecorder.cleanupOldFiles()
                            alertMessage = "Âè§„ÅÑÂΩ¢Âºè„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü"
                            showAlert = true
                        }) {
                            HStack {
                                Image(systemName: "trash.fill")
                                Text("Âè§„ÅÑ„Éï„Ç°„Ç§„É´ÂâäÈô§")
                            }
                            .font(.caption)
                            .padding(.horizontal, 12)
                            .padding(.vertical, 6)
                            .background(Color.safeColor("WarningColor"))
                            .foregroundColor(.white)
                            .cornerRadius(8)
                        }
                    }
                }
                .padding(.horizontal)
                
                // Èå≤Èü≥Áä∂ÊÖã„ÅÆË°®Á§∫„Ç®„É™„Ç¢
                if audioRecorder.isRecording {
                    // Èå≤Èü≥‰∏≠„ÅÆË°®Á§∫
                    VStack(spacing: 16) {
                        // Ê≥¢ÂΩ¢Ë°®Á§∫
                        HStack(spacing: 3) {
                            ForEach(0..<audioRecorder.audioLevels.count, id: \.self) { index in
                                RoundedRectangle(cornerRadius: 2)
                                    .fill(Color.safeColor("RecordingActive"))
                                    .frame(width: 4, height: max(4, audioRecorder.audioLevels[index] * 60))
                                    .animation(.easeInOut(duration: 0.05), value: audioRecorder.audioLevels[index])
                            }
                        }
                        .frame(height: 60)
                        
                        VStack(spacing: 8) {
                            Text("Èå≤Èü≥‰∏≠")
                                .font(.headline)
                                .foregroundColor(Color.safeColor("RecordingActive"))
                            
                            Text(audioRecorder.formatTime(audioRecorder.recordingTime))
                                .font(.title2)
                                .fontWeight(.bold)
                                .foregroundColor(Color.safeColor("RecordingActive"))
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.safeColor("RecordingActive").opacity(0.1))
                    .cornerRadius(12)
                }
                
                // Èå≤Èü≥„Éï„Ç°„Ç§„É´„É™„Çπ„Éà„Åæ„Åü„ÅØ„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº
                if audioRecorder.recordings.isEmpty && !audioRecorder.isRecording {
                    // „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº
                    VStack(spacing: 16) {
                        Image(systemName: "waveform")
                            .font(.system(size: 40))
                            .foregroundColor(Color.secondary.opacity(0.5))
                        Text("Èü≥Â£∞„Åã„Çâ„ÄÅÊ∞óÂàÜ„ÉªË°åÂãï„ÉªÊÑüÊÉÖ„ÇíÂàÜÊûê„Åó„Åæ„Åô")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        Text("Èå≤Èü≥„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
                            .font(.caption)
                            .foregroundColor(Color.secondary.opacity(0.7))
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 40)
                } else if !audioRecorder.recordings.isEmpty {
                    // Èå≤Èü≥„Éï„Ç°„Ç§„É´„É™„Çπ„Éà
                    VStack(spacing: 8) {
                        ForEach(audioRecorder.recordings, id: \.fileName) { recording in
                            RecordingRowView(
                                recording: recording,
                                isSelected: selectedRecording?.fileName == recording.fileName,
                                onSelect: { selectedRecording = recording },
                                onDelete: { recording in
                                    audioRecorder.deleteRecording(recording)
                                }
                            )
                        }
                    }
                    
                    // ‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Éú„Çø„É≥
                    if audioRecorder.recordings.filter({ !$0.isRecordingFailed && !$0.isUploaded && $0.canUpload }).count > 0 {
                        Button(action: {
                            manualBatchUpload()
                        }) {
                            HStack {
                                Image(systemName: "waveform.badge.magnifyingglass")
                                    .font(.title3)
                                Text("ÂàÜÊûêÈñãÂßã")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(Color.safeColor("AppAccentColor"))
                            .foregroundColor(.white)
                            .cornerRadius(12)
                        }
                        .padding(.bottom, 8)
                        .disabled(networkManager.connectionStatus == .uploading)
                    }
                }
            }
            .padding()
            .background(Color(.systemBackground))
            .cornerRadius(12)
                        }
                        .padding(.horizontal)
                        .padding(.bottom, 100) // Èå≤Èü≥„Éú„Çø„É≥„ÅÆ„Çπ„Éö„Éº„Çπ„ÇíÁ¢∫‰øù
                    }
                }
                
                // ‰∏ãÈÉ®Âõ∫ÂÆö„Éú„Çø„É≥
                VStack {
                    Spacer()
                    VStack(spacing: 0) {
                        Divider()
                        // Èå≤Èü≥ÈñãÂßã/ÂÅúÊ≠¢„Éú„Çø„É≥
                        if audioRecorder.isRecording {
                            // Èå≤Èü≥ÂÅúÊ≠¢„Éú„Çø„É≥
                            Button(action: {
                                audioRecorder.stopRecording()
                            }) {
                                HStack {
                                    Image(systemName: "stop.circle.fill")
                                        .font(.title2)
                                    Text("Èå≤Èü≥„ÇíÂÅúÊ≠¢")
                                        .font(.headline)
                                }
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.red)
                                .foregroundColor(.white)
                                .cornerRadius(12)
                            }
                            .padding()
                        } else {
                            // Èå≤Èü≥ÈñãÂßã„Éú„Çø„É≥
                            Button(action: {
                                // „Éá„Éê„Ç§„Çπ„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                                if deviceManager.selectedDeviceID == nil {
                                    // „Éá„Éê„Ç§„ÇπÊú™ÈÄ£Êê∫„ÅÆÂ†¥Âêà„ÄÅÈÄ£Êê∫Á¢∫Ë™ç„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
                                    showDeviceRegistrationConfirm = true
                                } else if !deviceManager.shouldShowFAB {
                                    alertMessage = "„Åì„ÅÆ„Éá„Éê„Ç§„Çπ„ÅØË¶≥Ê∏¨Â∞ÇÁî®„ÅÆ„Åü„ÇÅÈå≤Èü≥„Åß„Åç„Åæ„Åõ„Çì„ÄÇ"
                                    showAlert = true
                                } else {
                                    audioRecorder.startRecording()
                                }
                            }) {
                                HStack {
                                    Image(systemName: "mic.circle.fill")
                                        .font(.title2)
                                    Text("Èå≤Èü≥„ÇíÈñãÂßã")
                                        .font(.headline)
                                }
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(Color.safeColor("RecordingActive"))
                                .foregroundColor(.white)
                                .cornerRadius(12)
                            }
                            .padding()
                        }
                    }
                    .background(Color(.systemBackground))
                }
            }
            .navigationTitle("Èå≤Èü≥")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Èñâ„Åò„Çã") {
                    dismiss()
                }
            }
        }
        }
        .alert("ÈÄöÁü•", isPresented: $showAlert) {
            Button("OK", role: .cancel) { }
        } message: {
            Text(alertMessage)
        }
        .confirmationDialog("„Éá„Éê„Ç§„Çπ„ÇíÈÄ£Êê∫", isPresented: $showDeviceRegistrationConfirm, titleVisibility: .visible) {
            Button("ÈÄ£Êê∫") {
                Task {
                    await registerDevice()
                }
            }
            Button("„Ç≠„É£„É≥„Çª„É´", role: .cancel) { }
        } message: {
            Text("„Åì„ÅÆ„Éá„Éê„Ç§„Çπ„ÅÆ„Éû„Ç§„ÇØ„Çí‰Ωø„Å£„Å¶Èü≥Â£∞ÊÉÖÂ†±„ÇíÂàÜÊûê„Åó„Åæ„Åô")
        }
        .onAppear {
            // AudioRecorder„Å´DeviceManager„ÅÆÂèÇÁÖß„ÇíË®≠ÂÆö
            audioRecorder.deviceManager = deviceManager
            
            // ÂàùÊúüÂÄ§„ÇíË®≠ÂÆö
            updateTimeInfo()
            
            // „Çø„Ç§„Éû„Éº„ÇíÈñãÂßã„Åó„Å¶ÊôÇÈñì„Çπ„É≠„ÉÉ„Éà„Å®„Éá„Éê„Ç§„ÇπÊôÇÂàª„ÇíÊõ¥Êñ∞
            timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
                updateTimeInfo()
            }
        }
        .onDisappear {
            // „Çø„Ç§„Éû„Éº„ÇíÂÅúÊ≠¢
            timer?.invalidate()
            timer = nil
            
            // „Éì„É•„Éº„ÅåÈùûË°®Á§∫„Å´„Å™„Å£„Åü„ÇâÈå≤Èü≥„ÇíÂÅúÊ≠¢
            if audioRecorder.isRecording {
                audioRecorder.stopRecording()
            }
        }
    }
    
    // ÊôÇÂàª„Å®„Çπ„É≠„ÉÉ„ÉàÊÉÖÂ†±„ÇíÊõ¥Êñ∞
    private func updateTimeInfo() {
        // „Éá„Éê„Ç§„Çπ„ÅÆ„Çø„Ç§„É†„Çæ„Éº„É≥„ÇíËÄÉÊÖÆ„Åó„ÅüÁèæÂú®ÊôÇÂàª„ÇíÂèñÂæó
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyyÂπ¥MÊúàdÊó•"
        formatter.locale = Locale(identifier: "ja_JP")
        formatter.timeZone = deviceManager.selectedDeviceTimezone
        
        let dateString = formatter.string(from: Date())
        let timeSlot = SlotTimeUtility.getCurrentSlot(timezone: deviceManager.selectedDeviceTimezone)
        
        // ÊôÇÈñìÂ∏ØÂΩ¢Âºè„Å´Â§âÊèõ (‰æã: "14-30" -> "14:30-15:00")
        let timeRange = convertToTimeRange(timeSlot)
        
        // Âπ¥ÊúàÊó•„Å®ÊôÇÈñìÂ∏Ø„ÇíÁµÑ„ÅøÂêà„Çè„Åõ
        recordingDataPoint = "\(dateString) \(timeRange)"
    }
    
    // „Çø„Ç§„É†„Çπ„É≠„ÉÉ„Éà„ÇíÊôÇÈñìÂ∏ØÂΩ¢Âºè„Å´Â§âÊèõ
    private func convertToTimeRange(_ slot: String) -> String {
        // "14-30" -> ["14", "30"]
        let components = slot.split(separator: "-")
        guard components.count == 2,
              let hour = Int(components[0]),
              let minute = Int(components[1]) else {
            return slot
        }

        // ÈñãÂßãÊôÇÂàª
        let startTime = String(format: "%02d:%02d", hour, minute)

        // ÁµÇ‰∫ÜÊôÇÂàªÔºà30ÂàÜÂæåÔºâ
        var endHour = hour
        var endMinute = minute + 30
        if endMinute >= 60 {
            endHour += 1
            endMinute -= 60
        }
        if endHour >= 24 {
            endHour = 0
        }
        let endTime = String(format: "%02d:%02d", endHour, endMinute)

        return "\(startTime)-\(endTime)"
    }

    // MARK: - „Åì„ÅÆ„Éá„Éê„Ç§„Çπ„ÇíÁôªÈå≤„Åô„ÇãÂá¶ÁêÜ
    private func registerDevice() async {
        guard let userId = userAccountManager.currentUser?.profile?.userId else {
            print("‚ùå „É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
            await MainActor.run {
                alertMessage = "„É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
                showAlert = true
            }
            return
        }

        // DeviceManager„ÅÆregisterDevice„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„ÅôÔºàÂÆå‰∫Ü„Åæ„ÅßÂæÖÊ©üÔºâ
        await deviceManager.registerDevice(userId: userId)

        await MainActor.run {
            // „Ç®„É©„Éº„ÉÅ„Çß„ÉÉ„ÇØ
            if let error = deviceManager.registrationError {
                print("‚ùå „Éá„Éê„Ç§„ÇπÁôªÈå≤„Ç®„É©„Éº: \(error)")
                alertMessage = "„Éá„Éê„Ç§„ÇπÁôªÈå≤„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: \(error)"
                showAlert = true
            } else if !deviceManager.userDevices.isEmpty {
                // ÁôªÈå≤ÊàêÂäü - „Éá„Éê„Ç§„Çπ„ÅåËøΩÂä†„Åï„Çå„Åü„ÅÆ„ÅßUI„ÅåËá™ÂãïÁöÑ„Å´Êõ¥Êñ∞„Åï„Çå„Çã
                print("‚úÖ „Éá„Éê„Ç§„ÇπÁôªÈå≤ÊàêÂäü")
                // ÁôªÈå≤ÊàêÂäüÂæå„ÄÅÈå≤Èü≥„ÇíËá™ÂãïÁöÑ„Å´ÈñãÂßã
                audioRecorder.startRecording()
            } else {
                print("‚ùå „Éá„Éê„Ç§„Çπ„ÅÆÁôªÈå≤„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
                alertMessage = "„Éá„Éê„Ç§„Çπ„ÅÆÁôªÈå≤„Å´Â§±Êïó„Åó„Åæ„Åó„Åü"
                showAlert = true
            }
        }
    }

    // „Ç∑„É≥„Éó„É´„Å™‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÔºàNetworkManager„ÇíÁõ¥Êé•‰ΩøÁî®Ôºâ- ÈÄêÊ¨°ÂÆüË°åÁâà
    private func manualBatchUpload() {
        // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂØæË±°„ÅÆ„É™„Çπ„Éà„ÇíÂèñÂæóÔºàÈå≤Èü≥Â§±Êïó„Éï„Ç°„Ç§„É´„ÇíÈô§Â§ñÔºâ
        let recordingsToUpload = audioRecorder.recordings.filter { !$0.isRecordingFailed && $0.canUpload }
        
        guard !recordingsToUpload.isEmpty else {
            alertMessage = "„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂØæË±°„ÅÆ„Éï„Ç°„Ç§„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
            showAlert = true
            return
        }
        
        print("üì§ ‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÈñãÂßã: \(recordingsToUpload.count)‰ª∂")
        
        // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰ª∂Êï∞„ÇíË®≠ÂÆö
        uploadingTotalCount = recordingsToUpload.count
        uploadingCurrentIndex = 0
        
        // ÊúÄÂàù„ÅÆ„Éï„Ç°„Ç§„É´„Åã„Çâ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÈñãÂßã„Åô„Çã
        uploadSequentially(recordings: recordingsToUpload)
    }
    
    // ÂÜçÂ∏∞ÁöÑ„Å´„Éï„Ç°„Ç§„É´„Çí1„Å§„Åö„Å§„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åô„ÇãÈñ¢Êï∞
    private func uploadSequentially(recordings: [RecordingModel]) {
        // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åô„Çã„É™„Çπ„Éà„ÅåÁ©∫„Å´„Å™„Å£„Åü„ÇâÂá¶ÁêÜ„ÇíÁµÇ‰∫Ü
        guard let recording = recordings.first else {
            print("‚úÖ ÂÖ®„Å¶„ÅÆ‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ")
            DispatchQueue.main.async {
                self.alertMessage = "„Åô„Åπ„Å¶„ÅÆ‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ"
                self.showAlert = true
                // „Ç´„Ç¶„É≥„Çø„Éº„Çí„É™„Çª„ÉÉ„Éà
                self.uploadingTotalCount = 0
                self.uploadingCurrentIndex = 0
            }
            return
        }
        
        // „É™„Çπ„Éà„ÅÆÊÆã„Çä„ÇíÊ¨°„ÅÆÂá¶ÁêÜ„ÅÆ„Åü„ÇÅ„Å´Ê∫ñÂÇô
        var remainingRecordings = recordings
        remainingRecordings.removeFirst()
        
        // ÁèæÂú®„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁï™Âè∑„ÇíÊõ¥Êñ∞
        uploadingCurrentIndex = uploadingTotalCount - recordings.count + 1
        
        print("üì§ „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠: \(recording.fileName) (\(uploadingCurrentIndex)/\(uploadingTotalCount))")
        
        // 1„Å§„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
        networkManager.uploadRecording(recording) { success in
            if success {
                print("‚úÖ ‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊàêÂäü: \(recording.fileName)")
                
                // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÅåÊàêÂäü„Åó„Åü„ÅÆ„Åß„ÄÅ„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§„Åô„Çã
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                    print("üóëÔ∏è ÈÄÅ‰ø°Ê∏à„Åø„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§„Åó„Åæ„Åô:\(recording.fileName)")
                    self.audioRecorder.deleteRecording(recording)
                }
            } else {
                print("‚ùå ‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±Êïó: \(recording.fileName)")
            }
            
            // ÊàêÂäü„ÉªÂ§±Êïó„Å´„Åã„Åã„Çè„Çâ„Åö„ÄÅÊ¨°„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âëº„Å≥Âá∫„Åô
            self.uploadSequentially(recordings: remainingRecordings)
        }
    }
}

// MARK: - Èå≤Èü≥„Éï„Ç°„Ç§„É´Ë°å„ÅÆ„Éì„É•„Éº
struct RecordingRowView: View {
    @ObservedObject var recording: RecordingModel
    let isSelected: Bool
    let onSelect: () -> Void
    let onDelete: (RecordingModel) -> Void
    @EnvironmentObject var deviceManager: DeviceManager
    
    // „Éï„Ç°„Ç§„É´Âêç„Åã„ÇâÊó•‰ªò„ÇíÊäΩÂá∫
    private var recordingDate: String {
        // „Éï„Ç°„Ç§„É´ÂêçÂΩ¢Âºè: "2025-08-19/22-00.wav"
        let components = recording.fileName.split(separator: "/")
        guard components.count == 2 else { return "" }
        
        let dateString = String(components[0])
        
        // Êó•‰ªò„Çí„Éë„Éº„Çπ
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"
        dateFormatter.timeZone = deviceManager.selectedDeviceTimezone
        
        guard let date = dateFormatter.date(from: dateString) else {
            return dateString
        }
        
        // Êó•Êú¨Ë™ûÂΩ¢Âºè„ÅßÊó•‰ªò„ÇíË°®Á§∫
        let displayFormatter = DateFormatter()
        displayFormatter.dateFormat = "yyyyÂπ¥MÊúàdÊó•"
        displayFormatter.locale = Locale(identifier: "ja_JP")
        displayFormatter.timeZone = deviceManager.selectedDeviceTimezone
        
        return displayFormatter.string(from: date)
    }
    
    // „Éï„Ç°„Ç§„É´Âêç„Åã„ÇâÊôÇÈñìÂ∏Ø„ÇíÊäΩÂá∫
    private var recordingTimeRange: String {
        // „Éï„Ç°„Ç§„É´ÂêçÂΩ¢Âºè: "2025-08-19/22-00.wav"
        let components = recording.fileName.split(separator: "/")
        guard components.count == 2 else { return recording.fileName }
        
        let timeComponent = String(components[1]).replacingOccurrences(of: ".wav", with: "")
        
        // ÊôÇÈñìÂ∏ØÂΩ¢Âºè„Å´Â§âÊèõ (‰æã: "22-00" -> "22:00-22:30")
        return convertSlotToTimeRange(timeComponent)
    }
    
    // „Çπ„É≠„ÉÉ„Éà„ÇíÊôÇÈñìÂ∏ØÂΩ¢Âºè„Å´Â§âÊèõ
    private func convertSlotToTimeRange(_ slot: String) -> String {
        // "14-30" -> ["14", "30"]
        let components = slot.split(separator: "-")
        guard components.count == 2,
              let hour = Int(components[0]),
              let minute = Int(components[1]) else {
            return slot
        }
        
        // ÈñãÂßãÊôÇÂàª
        let startTime = String(format: "%02d:%02d", hour, minute)
        
        // ÁµÇ‰∫ÜÊôÇÂàªÔºà30ÂàÜÂæåÔºâ
        var endHour = hour
        var endMinute = minute + 30
        if endMinute >= 60 {
            endHour += 1
            endMinute -= 60
        }
        if endHour >= 24 {
            endHour = 0
        }
        let endTime = String(format: "%02d:%02d", endHour, endMinute)
        
        return "\(startTime)-\(endTime)"
    }
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                // Êó•‰ªòÔºàÂ∞è„Åï„ÅèË°®Á§∫Ôºâ
                Text(recordingDate)
                    .font(.caption2)
                    .foregroundColor(.secondary)
                
                HStack {
                    // ÊôÇÈñìÂ∏ØÔºàÂ§ß„Åç„ÅèË°®Á§∫Ôºâ
                    Text(recordingTimeRange)
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Spacer()
                    
                    // Èå≤Èü≥Â§±Êïó„Éï„Ç°„Ç§„É´„ÅÆÂ†¥Âêà„ÅØ„ÄåÈå≤Èü≥Â§±Êïó„Äç„ÇíË°®Á§∫
                    if recording.isRecordingFailed {
                        Text("Èå≤Èü≥Â§±Êïó")
                            .font(.caption)
                            .fontWeight(.bold)
                            .foregroundColor(Color.safeColor("ErrorColor"))
                    } else {
                        Text(recording.fileSizeFormatted)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                
                // Èå≤Èü≥Â§±Êïó„Éï„Ç°„Ç§„É´„ÅÆÂ†¥Âêà„ÅÆË™¨Êòé
                if recording.isRecordingFailed {
                    HStack {
                        Image(systemName: "xmark.circle.fill")
                            .font(.caption)
                            .foregroundColor(Color.safeColor("ErrorColor"))
                        
                        Text("Èü≥Â£∞„Éá„Éº„Çø„ÅÆÈå≤Èü≥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Éï„Ç°„Ç§„É´„ÅØËá™ÂãïÁöÑ„Å´ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ")
                            .font(.caption)
                            .foregroundColor(Color.safeColor("ErrorColor"))
                        
                        Spacer()
                    }
                }
                
                // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±ÊïóÊôÇ„ÅÆ„Åø„Ç®„É©„ÉºÊÉÖÂ†±„ÇíË°®Á§∫ÔºàÈå≤Èü≥Â§±Êïó„Éï„Ç°„Ç§„É´‰ª•Â§ñÔºâ
                if !recording.isRecordingFailed && recording.uploadAttempts > 0 && !recording.isUploaded {
                    HStack {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .font(.caption)
                            .foregroundColor(Color.safeColor("WarningColor"))
                        
                        Text("„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±Êïó (Ë©¶Ë°å: \(recording.uploadAttempts)/3)")
                            .font(.caption)
                            .foregroundColor(Color.safeColor("WarningColor"))
                        
                        Spacer()
                    }
                    
                    // Ë©≥Á¥∞„Å™„Ç®„É©„ÉºÊÉÖÂ†±
                    if let error = recording.lastUploadError {
                        Text(error)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .lineLimit(2)
                    }
                }
            }
            
            Spacer()
            
            HStack(spacing: 8) {
                // ÊúÄÂ§ßË©¶Ë°åÂõûÊï∞„Å´ÈÅî„Åó„ÅüÂ†¥Âêà„ÅØ„É™„Çª„ÉÉ„Éà„Éú„Çø„É≥„ÇíË°®Á§∫
                if recording.uploadAttempts >= 3 {
                    Button(action: {
                        recording.resetUploadStatus()
                        print("üîÑ „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁä∂ÊÖã„É™„Çª„ÉÉ„Éà: \(recording.fileName)")
                    }) {
                        Image(systemName: "arrow.clockwise")
                            .foregroundColor(Color.safeColor("WarningColor"))
                    }
                }
                
                // ÂâäÈô§„Éú„Çø„É≥
                Button(action: { onDelete(recording) }) {
                    Image(systemName: "trash")
                        .foregroundColor(Color.safeColor("RecordingActive"))
                }
            }
        }
        .padding()
        .background(isSelected ? Color.blue.opacity(0.1) : Color(.systemGray6))
        .cornerRadius(8)
        .onTapGesture {
            onSelect()
        }
    }
}

// Êó•‰ªò„Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº
extension DateFormatter {
    static func display(for deviceManager: DeviceManager) -> DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .medium
        formatter.locale = Locale.current
        // „Éá„Éê„Ç§„Çπ„ÅÆ„Çø„Ç§„É†„Çæ„Éº„É≥„Çí‰ΩøÁî®
        formatter.timeZone = deviceManager.selectedDeviceTimezone
        return formatter
    }
}

#Preview {
    let deviceManager = DeviceManager()
    let userAccountManager = UserAccountManager(deviceManager: deviceManager)
    return RecordingView(
        audioRecorder: AudioRecorder(),
        networkManager: NetworkManager(
            userAccountManager: userAccountManager,
            deviceManager: deviceManager
        )
    )
}